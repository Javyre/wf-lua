<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>wf-lua documentation</title>
    <link rel="stylesheet" href="../ldoc.css" type="text/css" />
</head>
<body>
<div id="container">
<div id="product">
	<div id="product_logo"></div>
	<div id="product_name"><big><b></b></big></div>
	<div id="product_description"></div>
</div> <!-- id="product" -->
<div id="main">
<!-- Menu -->
<nav id="navigation">
<br/>
<h1>wf-lua</h1>
<ul>
  <li><a href="../index.html">Index</a></li>
</ul>
<h2>Source</h2>
<ul class="nowrap">
  <li><strong>wf.lua</strong></li>
  <li><a href="../source/ipc.lua.html">ipc.lua</a></li>
</ul>
<h2>Modules</h2>
<ul class="nowrap">
  <li><a href="../modules/wf.html">wf</a></li>
  <li><a href="../modules/wf.ipc.html">wf.ipc</a></li>
</ul>
<h2>Topics</h2>
<ul class="">
  <li><a href="../topics/readme.md.html">readme</a></li>
</ul>
</nav> <!-- id="navigation" -->
<div id="content" class="verbatim-html">
    <h2>wf.lua</h2>
<pre>
<span class="comment">--- High-level lua bindings to Wayfire's API.
</span><span class="comment">--
</span><span class="comment">-- @author Javier A. Pollak
</span><span class="comment">-- @license GPL-v3
</span><span class="comment">-- @module wf
</span><span class="comment">--
</span><span class="global">require</span> <span class="string">'wf.wf_h'</span> <span class="comment">-- Load the wf.h c header.
</span><span class="global">require</span> <span class="string">'wf.ipc'</span>

<span class="keyword">local</span> ffi = <span class="global">require</span> <span class="string">'ffi'</span>
<span class="keyword">local</span> util = <span class="global">require</span> <span class="string">'wf.util'</span>
<span class="keyword">local</span> Log = <span class="global">require</span> <span class="string">'wf.log'</span>

<span class="comment">-- FFI Logic
</span>
<span class="keyword">local</span> Raw = {lifetime_callbacks = {}, signal_callbacks = {}}

<span class="keyword">local</span> <span class="keyword">function</span> object_id(emitter_ptr)
    <span class="keyword">return</span> <span class="global">tostring</span>(ffi.cast(<span class="string">'void *'</span>, emitter_ptr))
<span class="keyword">end</span>

<span class="comment">-- There is a cap on the amount of allowed lua-created C callbacks so we
</span><span class="comment">-- reuse this same one for all signals.
</span>Raw.event_callback = ffi.cast(<span class="string">"wflua_EventCallback"</span>,
                              <span class="keyword">function</span>(emitter, event_type, signal, signal_data)
    <span class="keyword">local</span> success, err = <span class="global">pcall</span>(<span class="keyword">function</span>()
        <span class="keyword">if</span> event_type == ffi.C.WFLUA_EVENT_TYPE_SIGNAL <span class="keyword">then</span>
            <span class="comment">-- NOTE: The address of the emitter is assumed to be constant for any
</span>            <span class="comment">-- given emitter.
</span>            <span class="comment">-- A signal was emitted to the signal_connection.
</span>            Log.<span class="global">debug</span>(<span class="string">'SIGNAL EVENT: on '</span> .. object_id(emitter) .. <span class="string">' : "'</span> ..
                          ffi.<span class="global">string</span>(signal) .. <span class="string">'"'</span>)

            <span class="keyword">local</span> emitter_signals = Raw.signal_callbacks[object_id(emitter)]
                                        .signals
            emitter_signals[ffi.<span class="global">string</span>(signal)]:call(emitter, signal_data)

        <span class="keyword">elseif</span> event_type == ffi.C.WFLUA_EVENT_TYPE_EMITTER_DESTROYED <span class="keyword">then</span>
            Log.<span class="global">debug</span>(<span class="string">'EMITTER DIED: '</span>, object_id(emitter))

            <span class="keyword">local</span> emitter_id = object_id(emitter)
            Raw.lifetime_callbacks[emitter_id]:call(emitter)
            Raw.lifetime_callbacks[emitter_id] = <span class="keyword">nil</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>)

    <span class="keyword">if</span> <span class="keyword">not</span> success <span class="keyword">then</span> Log.err(<span class="string">'Error in lua event-callback:\n'</span>, err) <span class="keyword">end</span>
<span class="keyword">end</span>)

<span class="keyword">function</span> Raw:subscribe_lifetime(emitter_ptr, handler)
    <span class="keyword">local</span> emitter = object_id(emitter_ptr)

    Log.<span class="global">debug</span>(<span class="string">'subscribing to '</span> .. emitter .. <span class="string">' lifetime'</span>)

    <span class="keyword">if</span> <span class="keyword">not</span> self.lifetime_callbacks[emitter] <span class="keyword">then</span>
        ffi.C.wflua_lifetime_subscribe(emitter_ptr)
        self.lifetime_callbacks[emitter] = util.Hook {handler}
    <span class="keyword">else</span>
        self.lifetime_callbacks[emitter]:hook(handler)
    <span class="keyword">end</span>
    <span class="keyword">return</span> handler
<span class="keyword">end</span>

<span class="keyword">function</span> Raw:unsubscribe_lifetime(emitter_ptr, handler)
    <span class="keyword">local</span> emitter = object_id(emitter_ptr)

    self.lifetime_callbacks[emitter]:unhook(handler)

    <span class="keyword">if</span> self.lifetime_callbacks[emitter]:is_empty() <span class="keyword">then</span>
        ffi.C.wflua_lifetime_unsubscribe(emitter_ptr)
        self.lifetime_callbacks[emitter] = <span class="keyword">nil</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">function</span> Raw:subscribe(emitter_ptr, signal, handler, opts)
    <span class="keyword">local</span> lifetime_cleanup = <span class="keyword">true</span>
    <span class="keyword">if</span> opts ~= <span class="keyword">nil</span> <span class="keyword">and</span> <span class="global">type</span>(opts) == <span class="string">'table'</span> <span class="keyword">then</span>
        <span class="keyword">if</span> opts.lifetime_cleanup == <span class="keyword">false</span> <span class="keyword">then</span> lifetime_cleanup = <span class="keyword">false</span> <span class="keyword">end</span>
    <span class="keyword">end</span>

    <span class="keyword">local</span> emitter = object_id(emitter_ptr)

    Log.<span class="global">debug</span>(<span class="string">'subscribing to '</span> .. emitter .. <span class="string">' '</span> .. signal)

    <span class="keyword">if</span> <span class="keyword">not</span> self.signal_callbacks[emitter] <span class="keyword">then</span>
        <span class="keyword">local</span> lifetime_handler = <span class="keyword">false</span>
        <span class="keyword">if</span> lifetime_cleanup <span class="keyword">then</span>
            <span class="comment">-- Clean up when the C++ emitter object dies.
</span>            lifetime_handler = self:subscribe_lifetime(emitter_ptr, <span class="keyword">function</span>()
                self.signal_callbacks[emitter] = <span class="keyword">nil</span>
                ffi.C.wflua_signal_unsubscribe_all(emitter_ptr)
            <span class="keyword">end</span>)
        <span class="keyword">end</span>
        self.signal_callbacks[emitter] = {
            lifetime_handler = lifetime_cleanup,
            signals = {}
        }
    <span class="keyword">end</span>

    <span class="keyword">local</span> emitter_cbs = self.signal_callbacks[emitter].signals
    <span class="keyword">if</span> <span class="keyword">not</span> emitter_cbs[signal] <span class="keyword">then</span>
        ffi.C.wflua_signal_subscribe(emitter_ptr, signal)

        emitter_cbs[signal] = util.Hook {handler}
    <span class="keyword">else</span>
        emitter_cbs[signal]:hook(handler)
    <span class="keyword">end</span>
    <span class="keyword">return</span> handler
<span class="keyword">end</span>

<span class="keyword">function</span> Raw:unsubscribe(emitter_ptr, signal, handler)
    <span class="keyword">local</span> emitter = object_id(emitter_ptr)

    <span class="keyword">local</span> emitter_entry = self.signal_callbacks[emitter]
    <span class="keyword">local</span> emitter_cbs = emitter_entry.signals
    emitter_cbs[signal]:unhook(handler)

    <span class="keyword">if</span> emitter_cbs[signal]:is_empty() <span class="keyword">then</span>
        ffi.C.wflua_signal_unsubscribe(emitter_ptr, signal)

        emitter_cbs[signal] = <span class="keyword">nil</span>

        <span class="comment">-- No signals being listened for for this emitter
</span>        <span class="keyword">if</span> <span class="keyword">not</span> <span class="global">next</span>(emitter_cbs) <span class="keyword">then</span>
            <span class="keyword">if</span> emitter_entry.lifetime_handler ~= <span class="keyword">false</span> <span class="keyword">then</span>
                <span class="comment">-- No longer need to listen for emitter destroyed
</span>                self.unsubscribe_lifetime(emitter_ptr,
                                          emitter_entry.lifetime_handler)
            <span class="keyword">end</span>
            self.signal_callbacks[emitter] = <span class="keyword">nil</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>

ffi.C.wflua_register_event_callback(Raw.event_callback)

<span class="comment">--- Set the value of an option.
</span><span class="comment">-- The option must already by registered by Wayfire.
</span><span class="comment">-- @local
</span><span class="keyword">function</span> Raw.set_option(sect, opt, val)
    <span class="keyword">local</span> val_str = <span class="global">string</span>.format(<span class="string">'%s'</span>, val)

    <span class="keyword">local</span> r = ffi.C.wf_set_option_str(sect, opt, val_str)

    <span class="keyword">if</span> r == ffi.C.WF_INVALID_OPTION_VALUE <span class="keyword">then</span>
        <span class="global">error</span>(<span class="global">string</span>.format(<span class="string">'`%s` is not a valid value for %s/%s'</span>, val, sect,
                            opt))
    <span class="keyword">elseif</span> r == ffi.C.WF_INVALID_OPTION_SECTION <span class="keyword">then</span>
        <span class="global">error</span>(<span class="global">string</span>.format(<span class="string">'`%s` is not a valid section name'</span>, sect))
    <span class="keyword">elseif</span> r == ffi.C.WF_INVALID_OPTION <span class="keyword">then</span>
        <span class="global">error</span>(<span class="global">string</span>.format(<span class="string">'`%s` is not a valid option in `%s`'</span>, opt, sect))
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">do</span>
    <span class="keyword">local</span> <span class="keyword">function</span> view_signal(sig_data)
        <span class="keyword">return</span> {view = ffi.C.wf_get_signaled_view(sig_data)}
    <span class="keyword">end</span>

    <span class="keyword">local</span> <span class="keyword">function</span> output_signal(sig_data)
        <span class="keyword">return</span> {output = ffi.C.wf_get_signaled_output(sig_data)}
    <span class="keyword">end</span>

    Raw.signal_data_converters = {
        core = {
            [<span class="string">'view-created'</span>] = view_signal,
            [<span class="string">'view-system-bell'</span>] = view_signal,
            [<span class="string">'output-gain-focus'</span>] = output_signal,
            [<span class="string">'output-stack-order-changed'</span>] = output_signal
        },
        [<span class="string">'output-layout'</span>] = {
            [<span class="string">'output-added'</span>] = output_signal,
            [<span class="string">'pre-remove'</span>] = output_signal,
            [<span class="string">'output-removed'</span>] = output_signal
        },
        output = {
            [<span class="string">'view-mapped'</span>] = view_signal,
            [<span class="string">'view-pre-unmapped'</span>] = view_signal,
            [<span class="string">'view-unmapped'</span>] = view_signal,
            [<span class="string">'view-set-sticky'</span>] = view_signal,
            [<span class="string">'view-decoration-state-updated'</span>] = view_signal,
            [<span class="string">'view-attached'</span>] = view_signal,
            [<span class="string">'view-layer-attached'</span>] = view_signal,
            [<span class="string">'view-detached'</span>] = view_signal,
            [<span class="string">'view-layer-detached'</span>] = view_signal,
            [<span class="string">'view-disappeared'</span>] = view_signal,
            [<span class="string">'view-focused'</span>] = view_signal,
            [<span class="string">'view-move-request'</span>] = view_signal,
            [<span class="string">'gain-focus'</span>] = output_signal,
            [<span class="string">'start-rendering'</span>] = output_signal,
            [<span class="string">'stack-order-changed'</span>] = output_signal
        },
        view = {
            [<span class="string">'mapped'</span>] = view_signal,
            [<span class="string">'pre-unmapped'</span>] = view_signal,
            [<span class="string">'unmapped'</span>] = view_signal,
            [<span class="string">'set-sticky'</span>] = view_signal,
            [<span class="string">'title-changed'</span>] = view_signal,
            [<span class="string">'app-id-changed'</span>] = view_signal,
            [<span class="string">'decoration-state-updated'</span>] = view_signal,
            [<span class="string">'ping-timeout'</span>] = view_signal,
            [<span class="string">'set-output'</span>] = output_signal
        }
    }
<span class="keyword">end</span>

<span class="keyword">function</span> Raw:convert_signal_data(<span class="global">type</span>, signal, raw_data)
    <span class="keyword">local</span> data_converter = self.signal_data_converters[<span class="global">type</span>][signal]

    <span class="comment">-- Without converting this raw_data pointer, it's essentially useless in
</span>    <span class="comment">-- lua-land.
</span>    <span class="keyword">if</span> <span class="keyword">not</span> data_converter <span class="keyword">then</span> <span class="keyword">return</span> <span class="keyword">nil</span> <span class="keyword">end</span>

    <span class="keyword">return</span> data_converter(raw_data)
<span class="keyword">end</span>

<span class="comment">---Functions
</span><span class="comment">-- @section Functions
</span>
<span class="comment">-- Public API
</span><span class="keyword">local</span> M = {}

<span class="comment">--- Set option values in a given section.
</span><span class="comment">--
</span><span class="comment">-- The section and option names must already be registered in wayfire by it or
</span><span class="comment">-- some plugin.
</span><span class="comment">--
</span><span class="comment">-- @usage
</span><span class="comment">-- --The arguments are passed in the form:
</span><span class="comment">-- set { 'section', option = value, ...}
</span><span class="comment">--
</span><span class="comment">-- -- The wayfire.ini equivalent:
</span><span class="comment">-- --
</span><span class="comment">-- -- [section]
</span><span class="comment">-- -- option = value
</span><span class="comment">-- -- ...
</span><span class="comment">-- @tparam {section,option=value,...} args
</span><a id="239"></a><span class="comment">-- @within Functions
</span><span class="keyword">function</span> M.set(args)
    <span class="keyword">if</span> <span class="global">type</span>(args) ~= <span class="string">'table'</span> <span class="keyword">then</span>
        <span class="global">error</span>(<span class="string">[[The arguments to set should be passed in the form:
                set { 'section', option = value, option2 = value, ... }]]</span>, <span class="number">2</span>)
    <span class="keyword">end</span>

    <span class="keyword">local</span> sect = args[<span class="number">1</span>]
    <span class="keyword">for</span> opt, val <span class="keyword">in</span> <span class="global">pairs</span>(args) <span class="keyword">do</span>
        <span class="keyword">if</span> opt ~= <span class="number">1</span> <span class="keyword">then</span> Raw.set_option(sect, opt, val) <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">---A rectangle.
</span><span class="comment">-- @field x
</span><span class="comment">-- @field y
</span><span class="comment">-- @field width
</span><span class="comment">-- @field height
</span><span class="comment">-- @type Geometry
</span>ffi.metatype(<span class="string">"wf_Geometry"</span>, {
    __tostring = <span class="keyword">function</span>(self)
        <span class="keyword">return</span> <span class="global">string</span>.format(<span class="string">"(%d,%d %dx%d)"</span>, self.x, self.y, self.width,
                             self.height)
    <span class="keyword">end</span>
})

<span class="comment">---Width-height dimensions.
</span><span class="comment">-- @field width
</span><span class="comment">-- @field height
</span><span class="comment">-- @type Dimensions
</span>ffi.metatype(<span class="string">"wf_Dimensions"</span>, {
    __tostring = <span class="keyword">function</span>(self)
        <span class="keyword">return</span> <span class="global">string</span>.format(<span class="string">"(%dx%d)"</span>, self.width, self.height)
    <span class="keyword">end</span>
})

<span class="comment">---Floating point coordinates.
</span><span class="comment">-- @field x
</span><span class="comment">-- @field y
</span><span class="comment">-- @type Pointf
</span>ffi.metatype(<span class="string">"wf_Pointf"</span>, {
    __tostring = <span class="keyword">function</span>(self)
        <span class="keyword">return</span> <span class="global">string</span>.format(<span class="string">"(%f,%f)"</span>, self.x, self.y)
    <span class="keyword">end</span>
})

<span class="comment">--- Lua-local data attached to wayfire objects.
</span><span class="comment">-- @type ObjectData
</span><span class="comment">-- @local
</span><span class="keyword">local</span> ObjectData = {
    data = {},

    <span class="comment">--- Store some data.
</span>    <span class="comment">--
</span>    <span class="comment">-- Delete some stored data by setting it to <code>nil</code>.
</span>    <span class="comment">-- @local
</span>    set = <span class="keyword">function</span>(self, object_ptr, key, value, opts)
        <span class="keyword">local</span> lifetime_cleanup = <span class="keyword">true</span>
        <span class="keyword">if</span> opts ~= <span class="keyword">nil</span> <span class="keyword">and</span> <span class="global">type</span>(opts) == <span class="string">'table'</span> <span class="keyword">then</span>
            <span class="keyword">if</span> opts.lifetime_cleanup == <span class="keyword">false</span> <span class="keyword">then</span>
                lifetime_cleanup = <span class="keyword">false</span>
            <span class="keyword">end</span>
        <span class="keyword">end</span>

        <span class="keyword">local</span> object = object_id(object_ptr)
        <span class="keyword">if</span> <span class="keyword">not</span> self.data[object] <span class="keyword">then</span>
            <span class="keyword">if</span> value == <span class="keyword">nil</span> <span class="keyword">then</span> <span class="keyword">return</span> <span class="keyword">end</span>

            self.data[object] = {[key] = value}
            <span class="keyword">if</span> lifetime_cleanup <span class="keyword">then</span>
                Raw:subscribe_lifetime(object_ptr,
                                       <span class="keyword">function</span>()
                    self.data[object] = <span class="keyword">nil</span>
                <span class="keyword">end</span>)
            <span class="keyword">end</span>
        <span class="keyword">else</span>
            self.data[object][key] = value
        <span class="keyword">end</span>
    <span class="keyword">end</span>,

    <span class="comment">--- Retrieve some stored data.
</span>    <span class="comment">-- @local
</span>    get = <span class="keyword">function</span>(self, object_ptr, key)
        <span class="keyword">return</span> self.data[object_id(object_ptr)][key]
    <span class="keyword">end</span>
}

<span class="keyword">do</span>
    <span class="comment">-- We don't need to actually call wayfire's get_core everytime since it should
</span>    <span class="comment">-- never change.
</span>    <span class="keyword">local</span> core = ffi.C.wf_get_core()
    <span class="keyword">function</span> M.get_core() <span class="keyword">return</span> core <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">---The Wayfire compositor instance.
</span><span class="comment">-- @usage local core = wf.get_core()
</span><span class="comment">-- -- move the cursor to (100, 100)
</span><span class="comment">-- core:warp_cursor({100, 100})
</span><span class="comment">-- @type Core
</span>ffi.metatype(<span class="string">"wf_Core"</span>, {
    __tostring = <span class="keyword">function</span>(self)
        <span class="keyword">return</span> ffi.<span class="global">string</span>(ffi.C.wf_Core_to_string(self))
    <span class="keyword">end</span>,
    __index = {
        <span class="comment">--- Set the cursor to the given name from the cursor theme.
</span>        <span class="comment">-- @tparam Core self the wayfire instance.
</span>        <span class="comment">-- @tparam string name the cursor name.
</span>        set_cursor = <span class="keyword">function</span>(self, name)<a id="345"></a>
            ffi.C.wf_Core_set_cursor(self, name)
        <span class="keyword">end</span>,

        <span class="comment">--- Request to hide the cursor.
</span>        <span class="comment">--
</span>        <span class="comment">-- Increments the hide-cursor reference count and hides the cursor if
</span>        <span class="comment">-- it is not already hidden.
</span>        <span class="comment">-- @tparam Core self the wayfire instance.
</span>        hide_cursor = <span class="keyword">function</span>(self) ffi.C.wf_Core_hide_cursor(self) <span class="keyword">end</span>,

        <span class="comment">--- Request to unhide the cursor.
</span>        <span class="comment">--
</span>        <span class="comment">-- Decrement the hide-cursor reference count. If it goes to 0, then the
</span>        <span class="comment">-- cursor is actually unhidden.
</span>        <span class="comment">-- @tparam Core self the wayfire instance.
</span>        unhide_cursor = <span class="keyword">function</span>(self) ffi.C.wf_Core_unhide_cursor(self) <span class="keyword">end</span>,

        <span class="comment">--- Move the cursor to the given point.
</span>        <span class="comment">--
</span>        <span class="comment">-- The point is interpreted as being in global coordinates.
</span>        <span class="comment">-- @tparam Core self the wayfire instance.
</span>        <span class="comment">-- @tparam Pointf position the cursor position.
</span>        warp_cursor = <span class="keyword">function</span>(self, position)
            ffi.C.wf_Core_warp_cursor(self, position)
        <span class="keyword">end</span>,

        <span class="comment">--- Get the cursor position in global coordinates.
</span>        <span class="comment">--
</span>        <span class="comment">-- @tparam Core self the wayfire instance.
</span>        <span class="comment">-- @treturn Pointf the cursor position.
</span>        get_cursor_position = <span class="keyword">function</span>(self)
            <span class="keyword">return</span> ffi.C.wf_Core_get_cursor_position(self)
        <span class="keyword">end</span>,

        <span class="comment">--- Get the view that currently has cursor focus.
</span>        <span class="comment">--
</span>        <span class="comment">-- @tparam Core self the wayfire instance.
</span>        <span class="comment">-- @treturn View the view that currently has cursor focus.
</span>        get_cursor_focus_view = <span class="keyword">function</span>(self)
            <span class="keyword">return</span> ffi.C.wf_Core_get_cursor_focus_view(self)
        <span class="keyword">end</span>,

        <span class="comment">--- Get the view that currently has touch focus.
</span>        <span class="comment">--
</span>        <span class="comment">-- @tparam Core self the wayfire instance.
</span>        <span class="comment">-- @treturn View the view that currently has touch focus.
</span>        get_touch_focus_view = <span class="keyword">function</span>(self)
            <span class="keyword">return</span> ffi.C.wf_Core_get_touch_focus_view(self)
        <span class="keyword">end</span>,

        <span class="comment">--- Get the view at the given point.
</span>        <span class="comment">--
</span>        <span class="comment">-- The point is interpreted as being in global coordinates.
</span>        <span class="comment">-- Returns <code>nil</code> if there is no view at the point.
</span>        <span class="comment">-- @tparam Core self the wayfire instance.
</span>        <span class="comment">-- @tparam Pointf point the point.
</span>        <span class="comment">-- @treturn ?View the view at the given point. Or nil if none.
</span>        get_view_at = <span class="keyword">function</span>(self, point)
            <span class="keyword">return</span> ffi.C.wf_Core_get_view_at(self, point)
        <span class="keyword">end</span>,

        <span class="comment">--- Give a view keyboard focus.
</span>        <span class="comment">--
</span>        <span class="comment">-- @tparam Core self the wayfire instance.
</span>        <span class="comment">-- @tparam View view the view to set as active.
</span>        set_active_view = <span class="keyword">function</span>(self, view)
            ffi.C.wf_Core_set_active_view(self, view)
        <span class="keyword">end</span>,

        <span class="comment">--- Focus the given view and it's output.
</span>        <span class="comment">--
</span>        <span class="comment">-- Also brings the view to the front of the stack.
</span>        <span class="comment">-- @tparam Core self the wayfire instance.
</span>        <span class="comment">-- @tparam View view the view to give focus to.
</span>        focus_view = <span class="keyword">function</span>(self, view)
            ffi.C.wf_Core_focus_view(self, view)
        <span class="keyword">end</span>,

        <span class="comment">--- Focus the given output.
</span>        <span class="comment">--
</span>        <span class="comment">-- @tparam Core self the wayfire instance.
</span>        <span class="comment">-- @tparam Output output the output to give focus to.
</span>        focus_output = <span class="keyword">function</span>(self, output)
            ffi.C.wf_Core_focus_output(self, output)
        <span class="keyword">end</span>,

        <span class="comment">--- Get the currently focused output.
</span>        <span class="comment">--
</span>        <span class="comment">-- @tparam Core self the wayfire instance.
</span>        <span class="comment">-- @treturn Output the currently focused output.
</span>        get_active_output = <span class="keyword">function</span>(self)
            <span class="keyword">return</span> ffi.C.wf_Core_get_active_output(self)
        <span class="keyword">end</span>,

        <span class="comment">--- Move the given view to the output.
</span>        <span class="comment">--
</span>        <span class="comment">-- If <code>reconf</code> is <code>true</code>, then clamp the view's geometry to the
</span>        <span class="comment">-- target output's geometry.
</span>        <span class="comment">-- @tparam Core self the wayfire instance.
</span>        <span class="comment">-- @tparam View view the view to move.
</span>        <span class="comment">-- @tparam Output new_output the output to move the view to.
</span>        <span class="comment">-- @tparam bool reconf whether to clamp the view's geometry to the
</span>        <span class="comment">-- target output geometry.
</span>        move_view_to_output = <span class="keyword">function</span>(self, view, new_output, reconf)
            <span class="keyword">if</span> reconf == <span class="keyword">nil</span> <span class="keyword">then</span> reconf = <span class="keyword">false</span> <span class="keyword">end</span>
            ffi.C.wf_Core_move_view_to_output(self, view, new_output, reconf)
        <span class="keyword">end</span>,

        <span class="comment">--- Get the Wayland socket name of the current Wayland session.
</span>        <span class="comment">--
</span>        <span class="comment">-- @tparam Core self the wayfire instance.
</span>        <span class="comment">-- @treturn string the Wayland socket name of the current Wayland
</span>        <span class="comment">-- session.
</span>        get_wayland_display = <span class="keyword">function</span>(self)
            <span class="keyword">return</span> ffi.<span class="global">string</span>(ffi.C.wf_Core_get_wayland_display(self))
        <span class="keyword">end</span>,

        <span class="comment">--- Get the XWayland display name.
</span>        <span class="comment">--
</span>        <span class="comment">-- @tparam Core self the wayfire instance.
</span>        <span class="comment">-- @treturn string the XWayland display name.
</span>        get_xwayland_display = <span class="keyword">function</span>(self)
            <span class="keyword">return</span> ffi.<span class="global">string</span>(ffi.C.wf_Core_get_xwayland_display(self))
        <span class="keyword">end</span>,

        <span class="comment">--- Run a command with the system POSIX shell.
</span>        <span class="comment">--
</span>        <span class="comment">-- Sets the correct <code>WAYLAND_DISPLAY</code> and <code>DISPLAY</code> variables as well as
</span>        <span class="comment">-- others in order to make the process properly aware of the Wayfire
</span>        <span class="comment">-- session.
</span>        <span class="comment">--
</span>        <span class="comment">-- @tparam Core self the wayfire instance.
</span>        <span class="comment">-- @tparam string command the command to run.
</span>        <span class="comment">-- @treturn int the PID of the process.
</span>        run = <span class="keyword">function</span>(self, command) ffi.C.wf_Core_run(self, command) <span class="keyword">end</span>,

        <span class="comment">--- Shutdown the whole Wayfire process.
</span>        <span class="comment">--
</span>        <span class="comment">-- @tparam Core self the wayfire instance.
</span>        shutdown = <span class="keyword">function</span>(self) ffi.C.wf_Core_shutdown(self) <span class="keyword">end</span>,

        <span class="comment">--- Get the OutputLayout object representing the layout of the outputs.
</span>        <span class="comment">--
</span>        <span class="comment">-- @tparam Core self the wayfire instance.
</span>        <span class="comment">-- @treturn OutputLayout the OutputLayout object representing the layout
</span>        <span class="comment">-- of the outputs.
</span>        get_output_layout = <span class="keyword">function</span>(self)
            <span class="keyword">return</span> ffi.C.wf_Core_get_output_layout(self)
        <span class="keyword">end</span>,

        <span class="comment">--- Hook into a signal on the Wayfire instance.
</span>        <span class="comment">--
</span>        <span class="comment">-- Start listening for and calling <code>handler</code> on this signal.
</span>        <span class="comment">-- The type of <code>data</code> depends on the signal being listened for.
</span>        <span class="comment">-- See (TODO: signal definitions page).
</span>        <span class="comment">--
</span>        <span class="comment">-- @usage wf.get_core():hook('reload-config', function(core, data)
</span>        <span class="comment">--     print('The wayfire config has been reloaded!')
</span>        <span class="comment">-- end)
</span>        <span class="comment">-- @usage
</span>        <span class="comment">-- local wf = require('wf')
</span>        <span class="comment">--
</span>        <span class="comment">-- -- Whatever the wayfire config file says, override the option value
</span>        <span class="comment">-- -- as soon as it's reloaded.
</span>        <span class="comment">-- do
</span>        <span class="comment">--     local my_settings = function()
</span>        <span class="comment">--         wf.set {'core', background_color = '#344B5DFF'}
</span>        <span class="comment">--     end
</span>        <span class="comment">--
</span>        <span class="comment">--     local core = wf.get_core()
</span>        <span class="comment">--     core:hook('reload-config', function(core, data)
</span>        <span class="comment">--         -- Config was reloaded
</span>        <span class="comment">--         my_settings()
</span>        <span class="comment">--     end)
</span>        <span class="comment">--
</span>        <span class="comment">--     my_settings()
</span>        <span class="comment">-- end
</span>        <span class="comment">-- @usage
</span>        <span class="comment">-- assert(handler == wf.get_core():hook('startup-finished', handler))
</span>        <span class="comment">--
</span>        <span class="comment">-- @tparam Core self
</span>        <span class="comment">-- @tparam string signal
</span>        <span class="comment">-- @tparam fn(core,data) handler
</span>        <span class="comment">-- @treturn fn(core,data) handler
</span>        hook = <span class="keyword">function</span>(self, signal, handler)
            <span class="keyword">local</span> raw_handler = <span class="keyword">function</span>(_emitter, data)
                data = Raw:convert_signal_data(<span class="string">'core'</span>, signal, data)
                handler(self, data)
            <span class="keyword">end</span>

            ObjectData:set(self, handler, raw_handler)
            Raw:subscribe(self, signal, raw_handler)
            <span class="keyword">return</span> handler
        <span class="keyword">end</span>,

        <span class="comment">--- Unhook from a signal on the Wayfire instance.
</span>        <span class="comment">--
</span>        <span class="comment">-- Stop listening for and calling <code>handler</code> on this signal.
</span>        <span class="comment">--
</span>        <span class="comment">-- @usage
</span>        <span class="comment">-- local handler = wf.get_core():hook('view-created',
</span>        <span class="comment">--                             function(core, data) end)
</span>        <span class="comment">-- core:unhook('view-created', handler)
</span>        <span class="comment">--
</span>        <span class="comment">-- @usage local core = wf.get_core()
</span>        <span class="comment">-- local handler = function() end
</span>        <span class="comment">-- core:hook('view-created', handler)
</span>        <span class="comment">-- core:hook('startup-finished', handler)
</span>        <span class="comment">-- core:unhook('view-created', handler)
</span>        <span class="comment">-- core:unhook('startup-finished', handler)
</span>        <span class="comment">--
</span>        <span class="comment">-- @tparam Core self
</span>        <span class="comment">-- @tparam string signal
</span>        <span class="comment">-- @tparam fn(core,data) handler
</span>        unhook = <span class="keyword">function</span>(self, signal, handler)
            <span class="keyword">local</span> raw_handler = ObjectData:get(self, handler)
            Raw:unsubscribe(self, signal, raw_handler)
            ObjectData:set(self, handler, <span class="keyword">nil</span>)
        <span class="keyword">end</span>
    }
})

<span class="comment">---The current layout of the outputs.
</span><span class="comment">--
</span><span class="comment">-- Mainly useful for hooking into output layout signals like <code>&quot;output-added&quot;</code>.
</span><span class="comment">--
</span><span class="comment">-- @usage local output_layout = wf.get_core():get_output_layout()
</span><span class="comment">-- output_layout:hook("output-added", function(output_layout, data)
</span><span class="comment">--     print("new output!", data.output)
</span><span class="comment">-- end)
</span><span class="comment">-- @type OutputLayout
</span>ffi.metatype(<span class="string">"wf_OutputLayout"</span>, {
    __tostring = <span class="keyword">function</span>(self)
        <span class="keyword">return</span> <span class="string">"OutputLayout{ "</span> .. self:get_num_outputs() .. <span class="string">" output(s) }"</span>
    <span class="keyword">end</span>,
    __index = {
        <span class="comment">--- Get the output at the given coordinates.
</span>        <span class="comment">--
</span>        <span class="comment">-- Returns nil if no output is on the specified coordinate.
</span>        <span class="comment">--
</span>        <span class="comment">-- @tparam OutputLayout self the output layout object.
</span>        <span class="comment">-- @tparam number x the X coordinate.
</span>        <span class="comment">-- @tparam number y the Y coordinate.
</span>        <span class="comment">-- @treturn Output the output at the given coordinates or nil.
</span>        get_output_at = <span class="keyword">function</span>(self, x, y)
            ffi.C.wf_OutputLayout_get_output_at(self, x, y)
        <span class="keyword">end</span>,

        <span class="comment">--- Get the output at the given coordinates and the closest point on it.
</span>        <span class="comment">--
</span>        <span class="comment">-- Returns <code>output, closest</code> meaning the output found at the given
</span>        <span class="comment">-- origin point and the closest point to the given origin on the output.
</span>        <span class="comment">--
</span>        <span class="comment">-- @tparam OutputLayout self the output layout object.
</span>        <span class="comment">-- @tparam Pointf origin The origin point to query for.
</span>        <span class="comment">-- @treturn Output the output at the given coordinates.
</span>        <span class="comment">-- @treturn Pointf the closest point to the origin inside the found
</span>        <span class="comment">-- output.
</span>        get_output_coords_at = <span class="keyword">function</span>(self, origin)
            <span class="keyword">local</span> closest = ffi.new(<span class="string">'wf_Pointf'</span>)
            <span class="keyword">local</span> output = ffi.C.wf_OutputLayout_get_output_coords_at(self,
                                                                      origin,
                                                                      closest)
            <span class="keyword">return</span> output, closest
        <span class="keyword">end</span>,

        <span class="comment">--- Get the number of current outputs.
</span>        <span class="comment">--
</span>        <span class="comment">-- @tparam OutputLayout self the output layout object.
</span>        <span class="comment">-- @treturn number the number of outputs.
</span>        get_num_outputs = <span class="keyword">function</span>(self)
            <span class="keyword">return</span> ffi.C.wf_OutputLayout_get_num_outputs(self)
        <span class="keyword">end</span>,

        <span class="comment">--- Iterate through the current outputs.
</span>        <span class="comment">--
</span>        <span class="comment">-- Start by calling this function with <code>nil</code> as parameter and then
</span>        <span class="comment">-- successively call it until the returned value is the same as the
</span>        <span class="comment">-- first call.
</span>        <span class="comment">--
</span>        <span class="comment">-- @usage local first = output_layout:get_next_output(nil)
</span>        <span class="comment">-- local output = first
</span>        <span class="comment">-- repeat
</span>        <span class="comment">--     print("Current output:", output)
</span>        <span class="comment">--     local output = output_layout:get_next_output(output)
</span>        <span class="comment">-- until output == first
</span>        <span class="comment">-- @tparam OutputLayout self the output layout object.
</span>        <span class="comment">-- @tparam Output prev the output to step forwards from.
</span>        <span class="comment">-- @treturn Output the next output.
</span>        get_next_output = <span class="keyword">function</span>(self, prev)
            <span class="keyword">return</span> ffi.C.wf_OutputLayout_get_next_output(self, prev)
        <span class="keyword">end</span>,

        <span class="comment">--- Get an output by name.
</span>        <span class="comment">--
</span>        <span class="comment">-- @tparam OutputLayout self the output layout object.
</span>        <span class="comment">-- @tparam string name the name of the output.
</span>        <span class="comment">-- @treturn Output the next output.
</span>        find_output = <span class="keyword">function</span>(self, name)
            <span class="keyword">return</span> ffi.C.wf_OutputLayout_find_output(self, name)
        <span class="keyword">end</span>,

        <span class="comment">-- COMBAK: write the hook/unhook methods for this. We need a special
</span>        <span class="comment">-- case in the Raw stuff to opt out of lifetime tracking since
</span>        <span class="comment">-- OutputLayout is not an object but just a signal provider.
</span>
        <span class="comment">--- Hook into a signal on the output layout.
</span>        <span class="comment">--
</span>        <span class="comment">-- Start listening for and calling <code>handler</code> on this signal.
</span>        <span class="comment">-- The type of <code>data</code> depends on the signal being listened for.
</span>        <span class="comment">-- See (TODO: signal definitions page).
</span>        <span class="comment">--
</span>        <span class="comment">-- @usage local layout = wf.get_core():get_output_layout()
</span>        <span class="comment">-- layout:hook('output-added', function(layout, data)
</span>        <span class="comment">--     print('An output has been added:', data.output)
</span>        <span class="comment">-- end)
</span>        <span class="comment">-- @usage
</span>        <span class="comment">-- assert(handler == layout:hook('output-removed', handler))
</span>        <span class="comment">--
</span>        <span class="comment">-- @tparam OutputLayout self
</span>        <span class="comment">-- @tparam string signal
</span>        <span class="comment">-- @tparam fn(layout,data) handler
</span>        <span class="comment">-- @treturn fn(layout,data) handler
</span>        hook = <span class="keyword">function</span>(self, signal, handler)
            <span class="keyword">local</span> raw_handler = <span class="keyword">function</span>(_emitter, data)
                data = Raw:convert_signal_data(<span class="string">'output-layout'</span>, signal, data)
                handler(self, data)
            <span class="keyword">end</span>

            ObjectData:set(self, handler, raw_handler,
                           {lifetime_cleanup = <span class="keyword">false</span>})
            Raw:subscribe(self, signal, raw_handler, {lifetime_cleanup = <span class="keyword">false</span>})
            <span class="keyword">return</span> handler
        <span class="keyword">end</span>,

        <span class="comment">--- Unhook from a signal on the output layout.
</span>        <span class="comment">--
</span>        <span class="comment">-- Stop listening for and calling <code>handler</code> on this signal.
</span>        <span class="comment">--
</span>        <span class="comment">-- @usage
</span>        <span class="comment">-- local handler = wf.get_core():hook('output-added',
</span>        <span class="comment">--                             function(layout, data) end)
</span>        <span class="comment">-- core:unhook('output-added', handler)
</span>        <span class="comment">--
</span>        <span class="comment">-- @usage local layout = wf.get_core():get_output_layout()
</span>        <span class="comment">-- local handler = function() end
</span>        <span class="comment">-- layout:hook('output-added', handler)
</span>        <span class="comment">-- layout:hook('output-removed', handler)
</span>        <span class="comment">-- layout:unhook('output-added', handler)
</span>        <span class="comment">-- layout:unhook('output-removed', handler)
</span>        <span class="comment">--
</span>        <span class="comment">-- @tparam OutputLayout self
</span>        <span class="comment">-- @tparam string signal
</span>        <span class="comment">-- @tparam fn(layout,data) handler
</span>        unhook = <span class="keyword">function</span>(self, signal, handler)
            <span class="keyword">local</span> raw_handler = ObjectData:get(self, handler)
            Raw:unsubscribe(self, signal, raw_handler)
            ObjectData:set(self, handler, <span class="keyword">nil</span>)
        <span class="keyword">end</span>
    }
})

<span class="comment">---A wayfire output.
</span><span class="comment">-- @usage local view = -- some View
</span><span class="comment">-- local output = view:get_output()
</span><span class="comment">-- output:ensure_visible(view)
</span><span class="comment">-- output:focus_view(view)
</span><span class="comment">-- @type Output
</span>ffi.metatype(<span class="string">"wf_Output"</span>, {
    __tostring = <span class="keyword">function</span>(self)
        <span class="keyword">return</span> ffi.<span class="global">string</span>(ffi.C.wf_Output_to_string(self))
    <span class="keyword">end</span>,
    __index = {
        <span class="comment">--- Get the screen size of this output.
</span>        <span class="comment">-- @tparam Output self the output.
</span>        <span class="comment">-- @treturn Dimensions the screen size.
</span>        get_screen_size = <span class="keyword">function</span>(self)
            <span class="keyword">return</span> ffi.C.wf_Output_get_screen_size(self)
        <span class="keyword">end</span>,

        <span class="comment">--- Get the screen size of this output as a Geometry.
</span>        <span class="comment">-- The <code>x,y</code> of the Geometry will be 0.
</span>        <span class="comment">-- @tparam Output self the output.
</span>        <span class="comment">-- @treturn Geometry the screen size.
</span>        get_relative_geometry = <span class="keyword">function</span>(self)
            <span class="keyword">return</span> ffi.C.wf_Output_get_relative_geometry(self)
        <span class="keyword">end</span>,

        <span class="comment">--- Get the geometry of the screen.
</span>        <span class="comment">-- This should include the screen dimensions as well as meaningful <code>x,y</code>
</span>        <span class="comment">-- coordinates.
</span>        <span class="comment">-- @tparam Output self the output.
</span>        <span class="comment">-- @treturn Geometry the screen geometry.
</span>        get_layout_geometry = <span class="keyword">function</span>(self)
            <span class="keyword">return</span> ffi.C.wf_Output_get_layout_geometry(self)
        <span class="keyword">end</span>,

        <span class="comment">--- Ensure the pointer is on this output.
</span>        <span class="comment">-- If the pointer isn't already on this output, move it.
</span>        <span class="comment">--
</span>        <span class="comment">-- If <code>center</code> is <code>true</code>, move the pointer to the center of the screen
</span>        <span class="comment">-- regardless of whether it is already on this output.
</span>        <span class="comment">-- @tparam Output self the output.
</span>        <span class="comment">-- @tparam bool center whether to unconditionally center the pointer.
</span>        ensure_pointer = <span class="keyword">function</span>(self, center)
            <span class="keyword">if</span> center == <span class="keyword">nil</span> <span class="keyword">then</span> center = <span class="keyword">false</span> <span class="keyword">end</span>
            ffi.C.wf_Output_ensure_pointer(self, center)
        <span class="keyword">end</span>,

        <span class="comment">--- Get the cursor position relative to the output.
</span>        <span class="comment">-- @tparam Output self the output.
</span>        <span class="comment">-- @treturn Geometry the screen geometry.
</span>        get_cursor_position = <span class="keyword">function</span>(self)
            <span class="keyword">return</span> ffi.C.wf_Output_get_cursor_position(self)
        <span class="keyword">end</span>,

        <span class="comment">--- Get the view at the top of the workspace layer.
</span>        <span class="comment">-- @tparam Output self the output.
</span>        <span class="comment">-- @treturn View the view at the top of the workspace layer.
</span>        get_top_view = <span class="keyword">function</span>(self)
            <span class="keyword">return</span> ffi.C.wf_Output_get_top_view(self)
        <span class="keyword">end</span>,

        <span class="comment">--- Get the most recently focused view on this output.
</span>        <span class="comment">-- @tparam Output self the output.
</span>        <span class="comment">-- @treturn View the view at the top of the workspace layer.
</span>        get_active_view = <span class="keyword">function</span>(self)
            <span class="keyword">return</span> ffi.C.wf_Output_get_active_view(self)
        <span class="keyword">end</span>,

        <span class="comment">--- Try to focus the view on this output.
</span>        <span class="comment">-- If <code>raise</code> is <code>true</code>, also raise it to the top of its layer.
</span>        <span class="comment">-- @tparam Output self the output.
</span>        <span class="comment">-- @tparam View view the view to focus.
</span>        <span class="comment">-- @tparam bool raise whether to raise the view.
</span>        <span class="comment">-- @treturn View the view at the top of the workspace layer.
</span>        focus_view = <span class="keyword">function</span>(self, view, raise)
            <span class="keyword">if</span> raise == <span class="keyword">nil</span> <span class="keyword">then</span> raise = <span class="keyword">false</span> <span class="keyword">end</span>
            ffi.C.wf_Output_focus_view(self, view, raise)
        <span class="keyword">end</span>,

        <span class="comment">--- Switch workspaces to make this view visible.
</span>        <span class="comment">-- @tparam Output self the output.
</span>        <span class="comment">-- @tparam View view the view to make visible.
</span>        <span class="comment">-- @treturn bool whether a workspace switch occurred.
</span>        ensure_visible = <span class="keyword">function</span>(self, view)
            <span class="keyword">return</span> ffi.C.wf_Output_ensure_visible(self, view)
        <span class="keyword">end</span>,

        <span class="comment">--- Get the output's workarea geometry.
</span>        <span class="comment">-- @tparam Output self the output.
</span>        <span class="comment">-- @treturn Geometry the the output's workarea.
</span>        get_workarea = <span class="keyword">function</span>(self)
            <span class="keyword">return</span> ffi.C.wf_Output_get_workarea(self)
        <span class="keyword">end</span>,

        <span class="comment">--- Hook into a signal on this output.
</span>        <span class="comment">--
</span>        <span class="comment">-- Start listening for and calling <code>handler</code> on this signal.
</span>        <span class="comment">-- The type of <code>data</code> depends on the signal being listened for.
</span>        <span class="comment">-- See (TODO: signal definitions page).
</span>        <span class="comment">--
</span>        <span class="comment">-- @usage output:hook('view-mapped', function(output, data)
</span>        <span class="comment">--     print('View ', data.view:get_title(), ' mapped!')
</span>        <span class="comment">-- end)
</span>        <span class="comment">-- @usage assert(handler == output:hook('view-focused', handler))
</span>        <span class="comment">--
</span>        <span class="comment">-- @tparam Output self
</span>        <span class="comment">-- @tparam string signal
</span>        <span class="comment">-- @tparam fn(output,data) handler
</span>        <span class="comment">-- @treturn fn(output,data) handler
</span>        hook = <span class="keyword">function</span>(self, signal, handler)
            <span class="keyword">local</span> raw_handler = <span class="keyword">function</span>(_emitter, data)
                data = Raw:convert_signal_data(<span class="string">'output'</span>, signal, data)
                handler(self, data)
            <span class="keyword">end</span>

            ObjectData:set(self, handler, raw_handler)
            Raw:subscribe(self, signal, raw_handler)
            <span class="keyword">return</span> handler
        <span class="keyword">end</span>,

        <span class="comment">--- Unhook from a signal on this output.
</span>        <span class="comment">--
</span>        <span class="comment">-- Stop listening for and calling <code>handler</code> on this signal.
</span>        <span class="comment">--
</span>        <span class="comment">-- @usage
</span>        <span class="comment">-- local handler = output:hook('view-focused',
</span>        <span class="comment">--                             function(output, data) end)
</span>        <span class="comment">-- output:unhook('view-focused', handler)
</span>        <span class="comment">--
</span>        <span class="comment">-- @usage local handler = function() end
</span>        <span class="comment">-- output:hook('view-mapped', handler)
</span>        <span class="comment">-- output:hook('view-focused', handler)
</span>        <span class="comment">-- output:unhook('view-mapped', handler)
</span>        <span class="comment">-- output:unhook('view-focused', handler)
</span>        <span class="comment">--
</span>        <span class="comment">-- @tparam Output self
</span>        <span class="comment">-- @tparam string signal
</span>        <span class="comment">-- @tparam fn(output,data) handler
</span>        unhook = <span class="keyword">function</span>(self, signal, handler)
            <span class="keyword">local</span> raw_handler = ObjectData:get(self, handler)
            Raw:unsubscribe(self, signal, raw_handler)
            ObjectData:set(self, handler, <span class="keyword">nil</span>)
        <span class="keyword">end</span>
    }
})

<span class="comment">---A wayfire view.
</span><span class="comment">-- @usage
</span><span class="comment">-- -- If view is foot, then set its geometry and hook into the 'title-changed'
</span><span class="comment">-- -- event of this view.
</span><span class="comment">-- if view:get_app_id() == 'foot' then
</span><span class="comment">--     view:set_geometry({1, 2, 500, 300})
</span><span class="comment">--
</span><span class="comment">--     view:hook('title-changed', function(view, data)
</span><span class="comment">--         print('View title changed! New title:', data.view:get_title())
</span><span class="comment">--         assert(view == data.view)
</span><span class="comment">--     end)
</span><span class="comment">-- end
</span><span class="comment">-- @type View
</span>ffi.metatype(<span class="string">"wf_View"</span>, {
    __tostring = <span class="keyword">function</span>(self)
        <span class="keyword">return</span> ffi.<span class="global">string</span>(ffi.C.wf_View_to_string(self))
    <span class="keyword">end</span>,
    __index = {
        <span class="comment">--- Get the view's title.
</span>        <span class="comment">-- @tparam View self the view.
</span>        <span class="comment">-- @treturn string the view's title.
</span>        get_title = <span class="keyword">function</span>(self)
            <span class="keyword">return</span> ffi.<span class="global">string</span>(ffi.C.wf_View_get_title(self))
        <span class="keyword">end</span>,

        <span class="comment">--- Get the view's app id.
</span>        <span class="comment">-- @tparam View self the view.
</span>        <span class="comment">-- @treturn string the view's app id.
</span>        get_app_id = <span class="keyword">function</span>(self)
            <span class="keyword">return</span> ffi.<span class="global">string</span>(ffi.C.wf_View_get_app_id(self))
        <span class="keyword">end</span>,

        <span class="comment">--- Get the view's wm geometry.
</span>        <span class="comment">-- @tparam View self the view.
</span>        <span class="comment">-- @treturn Geometry the view's wm geometry.
</span>        get_wm_geometry = <span class="keyword">function</span>(self)
            <span class="keyword">return</span> ffi.C.wf_View_get_wm_geometry(self)
        <span class="keyword">end</span>,

        <span class="comment">--- Get the view's output geometry.
</span>        <span class="comment">-- @tparam View self the view.
</span>        <span class="comment">-- @treturn Geometry the view's output geometry.
</span>        get_output_geometry = <span class="keyword">function</span>(self)
            <span class="keyword">return</span> ffi.C.wf_View_get_output_geometry(self)
        <span class="keyword">end</span>,

        <span class="comment">--- Get the view's bounding box.
</span>        <span class="comment">-- @tparam View self the view.
</span>        <span class="comment">-- @treturn Geometry the view's bounding box.
</span>        get_bounding_box = <span class="keyword">function</span>(self)
            <span class="keyword">return</span> ffi.C.wf_View_get_bounding_box(self)
        <span class="keyword">end</span>,

        <span class="comment">--- Get the view's output.
</span>        <span class="comment">-- @tparam View self the view.
</span>        <span class="comment">-- @treturn Output the output the view is on.
</span>        get_output = <span class="keyword">function</span>(self) <span class="keyword">return</span> ffi.C.wf_View_get_output(self) <span class="keyword">end</span>,

        <span class="comment">--- Set the view's geometry.
</span>        <span class="comment">-- @tparam View self the view.
</span>        <span class="comment">-- @tparam Geometry geo the view's new geometry.
</span>        <span class="comment">-- @usage view:set_geometry({x, y, w, h})
</span>        set_geometry = <span class="keyword">function</span>(self, geo)
            <span class="keyword">return</span> ffi.C.wf_View_set_geometry(self, geo)
        <span class="keyword">end</span>,

        <span class="comment">--- Hook into a signal on this view.
</span>        <span class="comment">--
</span>        <span class="comment">-- Start listening for and calling <code>handler</code> on this signal.
</span>        <span class="comment">-- The type of <code>data</code> depends on the signal being listened for.
</span>        <span class="comment">-- See (TODO: signal definitions page).
</span>        <span class="comment">--
</span>        <span class="comment">-- @usage view:hook('title-changed', function(view, data)
</span>        <span class="comment">--     print('View title changed! New title:', data.view:get_title())
</span>        <span class="comment">--     assert(view == data.view)
</span>        <span class="comment">-- end)
</span>        <span class="comment">-- @usage assert(handler == view:hook('title-changed', handler))
</span>        <span class="comment">--
</span>        <span class="comment">-- @tparam View self
</span>        <span class="comment">-- @tparam string signal
</span>        <span class="comment">-- @tparam fn(view,data) handler
</span>        <span class="comment">-- @treturn fn(view,data) handler
</span>        hook = <span class="keyword">function</span>(self, signal, handler)
            <span class="keyword">local</span> raw_handler = <span class="keyword">function</span>(_emitter, data)
                data = Raw:convert_signal_data(<span class="string">'view'</span>, signal, data)
                handler(self, data)
            <span class="keyword">end</span>

            ObjectData:set(self, handler, raw_handler)
            Raw:subscribe(self, signal, raw_handler)
            <span class="keyword">return</span> handler
        <span class="keyword">end</span>,

        <span class="comment">--- Unhook from a signal on this view.
</span>        <span class="comment">--
</span>        <span class="comment">-- Stop listening for and calling <code>handler</code> on this signal.
</span>        <span class="comment">--
</span>        <span class="comment">-- @usage local handler = view:hook('title-changed', function(view, data) end)
</span>        <span class="comment">-- view:unhook('title-changed', handler)
</span>        <span class="comment">--
</span>        <span class="comment">-- @usage local handler = function() end
</span>        <span class="comment">-- view:hook('title-changed', handler)
</span>        <span class="comment">-- view:hook('app-id-changed', handler)
</span>        <span class="comment">-- view:unhook('title-changed', handler)
</span>        <span class="comment">-- view:unhook('app-id-changed', handler)
</span>        <span class="comment">--
</span>        <span class="comment">-- @tparam View self
</span>        <span class="comment">-- @tparam string signal
</span>        <span class="comment">-- @tparam fn(view,data) handler
</span>        unhook = <span class="keyword">function</span>(self, signal, handler)
            <span class="keyword">local</span> raw_handler = ObjectData:get(self, handler)
            Raw:unsubscribe(self, signal, raw_handler)
            ObjectData:set(self, handler, <span class="keyword">nil</span>)
        <span class="keyword">end</span>
    }
})

<span class="comment">-- Outputs represented as a single outputs table since there is only only
</span><span class="comment">-- central wflua instance per wayfire session.
</span><span class="keyword">do</span>
    <span class="keyword">local</span> outputs = {_hooked_signals = {}}
    <span class="keyword">local</span> output_layout = M.get_core():get_output_layout()

    <span class="comment">-- Populate output pointers
</span>    <span class="keyword">do</span>
        <span class="keyword">local</span> _raw_outputs = {}

        <span class="keyword">local</span> first = output_layout:get_next_output(<span class="keyword">nil</span>)
        <span class="keyword">local</span> output = first
        <span class="keyword">repeat</span>
            _raw_outputs[object_id(output)] = output

            <span class="keyword">local</span> output = output_layout:get_next_output(output)
        <span class="keyword">until</span> output == first

        outputs._raw_outputs = _raw_outputs
    <span class="keyword">end</span>

    <span class="comment">-- Update the raw_outputs list appropriately
</span>    <span class="keyword">do</span>
        output_layout:hook(<span class="string">'output-added'</span>, <span class="keyword">function</span>(layout, data)
            <span class="keyword">if</span> outputs._raw_outputs[object_id(data.output)] == <span class="keyword">nil</span> <span class="keyword">then</span>
                outputs._raw_outputs[object_id(data.output)] = data.output
                <span class="keyword">for</span> _, sig <span class="keyword">in</span> <span class="global">pairs</span>(outputs._hooked_signals) <span class="keyword">do</span>
                    data.output:hook(sig.signal, sig.handler)
                <span class="keyword">end</span>
            <span class="keyword">end</span>
        <span class="keyword">end</span>)
        output_layout:hook(<span class="string">'output-removed'</span>, <span class="keyword">function</span>(layout, data)
            outputs._raw_outputs[object_id(data.output)] = <span class="keyword">nil</span>
            <span class="comment">-- No need to unhook signals as this is taken care of by the
</span>            <span class="comment">-- lifetime cleanup of the output object.
</span>        <span class="keyword">end</span>)
    <span class="keyword">end</span>

    <span class="comment">--- Hook into a signal on all outputs.
</span>    <span class="comment">--
</span>    <span class="comment">-- Start listening for and calling <code>handler</code> on this signal.
</span>    <span class="comment">-- <code>output</code> is the specific <code>Output</code> that triggered the signal.
</span>    <span class="comment">-- The type of <code>data</code> depends on the signal being listened for.
</span>    <span class="comment">-- See (TODO: signal definitions page).
</span>    <span class="comment">--
</span>    <span class="comment">-- Note that this differs from calling <code>Output:hook()</code> on a specific
</span>    <span class="comment">-- <code>output</code> as we are hooking into this signal for *all* outputs
</span>    <span class="comment">-- simultaneously.
</span>    <span class="comment">--
</span>    <span class="comment">-- @usage
</span>    <span class="comment">-- local wf = require 'wf'
</span>    <span class="comment">--
</span>    <span class="comment">-- wf.outputs:hook('view-focused', function(output, data)
</span>    <span class="comment">--     print('View ', data.view, ' focused on output ', output)
</span>    <span class="comment">-- end)
</span>    <span class="comment">-- @usage assert(handler == wf.outputs:hook('view-focused', handler))
</span>    <span class="comment">--
</span>    <span class="comment">-- @tparam string signal
</span>    <span class="comment">-- @tparam fn(output,data) handler
</span>    <span class="comment">-- @treturn fn(output,data) handler
</span>    <span class="comment">-- @within Functions
</span>    <span class="keyword">function</span> outputs:hook(signal, handler)
        self._hooked_signals[signal .. <span class="global">tostring</span>(handler)] = {
            signal = signal,
            handler = handler
        }
        <span class="keyword">for</span> _, output <span class="keyword">in</span> <span class="global">pairs</span>(self._raw_outputs) <span class="keyword">do</span>
            output:hook(signal, handler)
        <span class="keyword">end</span>
        <span class="keyword">return</span> handler
    <span class="keyword">end</span>

    <span class="comment">--- Unhook from a signal on all outputs.
</span>    <span class="comment">--
</span>    <span class="comment">-- Stop listening for and calling <code>handler</code> on this signal.
</span>    <span class="comment">-- @usage
</span>    <span class="comment">-- local handler = wf.outputs:hook('view-focused',
</span>    <span class="comment">--                                 function(output, data) end)
</span>    <span class="comment">-- wf.outputs:unhook('view-focused', handler)
</span>    <span class="comment">--
</span>    <span class="comment">-- @usage local handler = function() end
</span>    <span class="comment">-- wf.outputs:hook('view-mapped', handler)
</span>    <span class="comment">-- wf.outputs:hook('view-focused', handler)
</span>    <span class="comment">-- wf.outputs:unhook('view-mapped', handler)
</span>    <span class="comment">-- wf.outputs:unhook('view-focused', handler)
</span>    <span class="comment">--
</span>    <span class="comment">-- @tparam string signal
</span>    <span class="comment">-- @tparam fn(output,data) handler
</span>    <span class="comment">-- @within Functions
</span>    <span class="keyword">function</span> outputs:unhook(signal, handler)
        self._hooked_signals[signal .. <span class="global">tostring</span>(handler)] = <span class="keyword">nil</span>
        <span class="keyword">for</span> _, output <span class="keyword">in</span> <span class="global">pairs</span>(self._raw_outputs) <span class="keyword">do</span>
            output:unhook(signal, handler)
        <span class="keyword">end</span>
        <span class="keyword">return</span> handler
    <span class="keyword">end</span>

    M.outputs = outputs
<span class="keyword">end</span>

<span class="keyword">return</span> M</pre>

</div> <!-- id="content" -->
</div> <!-- id="main" -->
<div id="about">
<i>generated by <a href="http://github.com/stevedonovan/LDoc">LDoc 1.4.6</a></i>
<i style="float:right;">Last updated 2021-12-26 19:25:54 </i>
</div> <!-- id="about" -->
</div> <!-- id="container" -->
</body>
</html>
